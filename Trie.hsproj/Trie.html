<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Trie</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Trie.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Trie</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Query</a></li><li><a href="#g:2">Construction</a></li><li><a href="#g:3">Insertion</a></li><li><a href="#g:4">Delete/Update</a></li><li><a href="#g:5">Combine</a></li><li><a href="#g:6">Folds</a></li><li><a href="#g:7">Lists</a></li><li><a href="#g:8">Filters</a></li><li><a href="#g:9">Debugging</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:null">null</a> :: <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</li><li class="src short"><a href="#v:size">size</a> :: <a href="Trie.html#t:Trie">Trie</a> a -&gt; Int</li><li class="src short"><a href="#v:member">member</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</li><li class="src short"><a href="#v:complete">complete</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:hasPref">hasPref</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</li><li class="src short"><a href="#v:hasSuff">hasSuff</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</li><li class="src short"><a href="#v:hasSub">hasSub</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</li><li class="src short"><a href="#v:follow">follow</a> :: (Ord a, Foldable f) =&gt; b -&gt; (<a href="Trie.html#t:Trie">Trie</a> a -&gt; b) -&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; b</li><li class="src short"><a href="#v:empty">empty</a> :: <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:singleton">singleton</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:insert">insert</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:delete">delete</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:toggle">toggle</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:alter">alter</a> :: (Ord a, Foldable f) =&gt; ((<a href="Trie.html#t:Trie">Trie</a> a -&gt; Maybe (<a href="Trie.html#t:Trie">Trie</a> a)) -&gt; Maybe (<a href="Trie.html#t:Trie">Trie</a> a) -&gt; Maybe (<a href="Trie.html#t:Trie">Trie</a> a)) -&gt; (<a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a) -&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:difference">difference</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:symmetricDifference">symmetricDifference</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:union">union</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:unions">unions</a> :: (Ord a, Foldable f) =&gt; f (<a href="Trie.html#t:Trie">Trie</a> a) -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:intersection">intersection</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:foldrTrie">foldrTrie</a> :: ([a] -&gt; b -&gt; b) -&gt; b -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; b</li><li class="src short"><a href="#v:toList">toList</a> :: <a href="Trie.html#t:Trie">Trie</a> a -&gt; [[a]]</li><li class="src short"><a href="#v:fromList">fromList</a> :: (Ord a, Foldable f, Foldable g) =&gt; g (f a) -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:begins">begins</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:ends">ends</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</li><li class="src short"><a href="#v:showTrie">showTrie</a> :: Show a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; String</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Trie" class="def">Trie</a> a</p><div class="subs instances"><p id="control.i:Trie" class="caption collapser" onclick="toggleSection('i:Trie')">Instances</p><div id="section.i:Trie" class="show"><table><tr><td class="src clearfix"><span class="inst-left">Eq a =&gt; Eq (<a href="Trie.html#t:Trie">Trie</a> a)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Show a =&gt; Show (<a href="Trie.html#t:Trie">Trie</a> a)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Ord a =&gt; Monoid (<a href="Trie.html#t:Trie">Trie</a> a)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:1">Query</h1><div class="top"><p class="src"><a name="v:null" class="def">null</a> :: <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</p><div class="doc"><p><em>O(1)</em>. Is this the empty Trie?</p></div></div><div class="top"><p class="src"><a name="v:size" class="def">size</a> :: <a href="Trie.html#t:Trie">Trie</a> a -&gt; Int</p><div class="doc"><p><em>O(n)</em>. The number of members in the Trie.</p></div></div><div class="top"><p class="src"><a name="v:member" class="def">member</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</p><div class="doc"><p><em>O(n)</em>. Is the element in the Trie?</p></div></div><div class="top"><p class="src"><a name="v:complete" class="def">complete</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p><em>O(n)</em>. Creates a Trie of all of the completions of a given 
 member.</p><pre>let t = fromList [&quot;hello&quot;, &quot;house&quot;, &quot;roundabout&quot;]
complete &quot;h&quot; t == fromList [&quot;ello&quot;, &quot;ouse&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:hasPref" class="def">hasPref</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</p><div class="doc"><p><em>O(n)</em>. Does the Trie contain a member with this prefix?</p><pre>let t = fromList [&quot;hello&quot;, &quot;house&quot;, &quot;roundabout&quot;]
hasPref &quot;hell&quot;  t == True
hasPref &quot;hello&quot; t == True
hasPref &quot;abc&quot;   t == False</pre></div></div><div class="top"><p class="src"><a name="v:hasSuff" class="def">hasSuff</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</p><div class="doc"><p><em>O(n * m)</em>, where m is the longest member of the Trie. 
 Does the Trie contain a member with this suffix?</p><pre>let t = fromList [&quot;hello&quot;, &quot;house&quot;, &quot;roundabout&quot;]
hasSuff &quot;hell&quot;  t == False
hasSuff &quot;about&quot; t == True</pre></div></div><div class="top"><p class="src"><a name="v:hasSub" class="def">hasSub</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; Bool</p><div class="doc"><p><em>O(n * m)</em>, where m is the longest member of the Trie. 
 Does the Trie contain a member with this infix?</p></div></div><div class="top"><p class="src"><a name="v:follow" class="def">follow</a> :: (Ord a, Foldable f) =&gt; b -&gt; (<a href="Trie.html#t:Trie">Trie</a> a -&gt; b) -&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; b</p><div class="doc"><p>A universal function for querying a Trie with a <code>Foldable</code>. When
 calling <code><code><a href="Trie.html#v:follow">follow</a></code> base f</code>, a function which takes a 
 <code>Foldable</code> and a Trie is created such that the <code>Foldable</code> is 
 followed until either the <code>Foldable</code> runs out, or its next element
 can't be found in the Trie.</p><ul><li>If the <code>Foldable</code> is exhausted, <code>f</code> is called on the remaining
 Trie.</li><li>If the next element in the <code>Foldable</code> cannot be found, <code>base</code> is
 returned.</li></ul><p>This function can be thought of as parallel to <code><a href="Trie.html#v:alter">alter</a></code>, but it 
 discards the Trie that's being queried, and only keeps the final 
 level reached with the <code>Foldable</code>.</p><p>Examples:</p><ul><li>Member</li></ul><pre>member = follow False endHere</pre><p>Here, the first argument <code>False</code> is returned if any element of the 
 <code>Foldable</code> cannot be found, and <code>endHere</code> is called on the final 
 Trie found. i.e., this function follows the <code>Foldable</code> along the 
 Trie, until it can't find the next element, so it returns <code>False</code>,
 or it ends, so it asks the current Trie if it's a final Trie.</p><ul><li>Complete</li></ul><pre>complete = follow empty id</pre><p>Here, the empty Trie is returned if the entire <code>Foldable</code> can't be 
 found, or the final Trie you reach is returned if the <code>Foldable</code> 
 is exhausted.</p></div></div><h1 id="g:2">Construction</h1><div class="top"><p class="src"><a name="v:empty" class="def">empty</a> :: <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p><em>O(1)</em>. The empty Trie.</p></div></div><div class="top"><p class="src"><a name="v:singleton" class="def">singleton</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p><em>O(n)</em>. Constructs a Trie with one member.</p></div></div><h1 id="g:3">Insertion</h1><div class="top"><p class="src"><a name="v:insert" class="def">insert</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p><em>O(n)</em>. Insert a new member into the Trie.</p></div></div><h1 id="g:4">Delete/Update</h1><div class="top"><p class="src"><a name="v:delete" class="def">delete</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p><em>O(n)</em>. Removes a member from the Trie.</p></div></div><div class="top"><p class="src"><a name="v:toggle" class="def">toggle</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p><em>O(n)</em>. Removes a member from the Trie if it is present, or
 inserts it if it is not.</p></div></div><div class="top"><p class="src"><a name="v:alter" class="def">alter</a> :: (Ord a, Foldable f) =&gt; ((<a href="Trie.html#t:Trie">Trie</a> a -&gt; Maybe (<a href="Trie.html#t:Trie">Trie</a> a)) -&gt; Maybe (<a href="Trie.html#t:Trie">Trie</a> a) -&gt; Maybe (<a href="Trie.html#t:Trie">Trie</a> a)) -&gt; (<a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a) -&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>A universal function for modifying a Trie with a <code>Foldable</code>. 
 When called with two arguments, <code><code><a href="Trie.html#v:alter">alter</a></code> atFind atEnd</code>, a function
 is created, such that</p><ul><li>atEnd is called on the lowest level Trie, i.e., the one reached 
 if the entire <code>Foldable</code> is followed and exhausted.</li><li>atFind is called on the looked-up Trie at every element of the
 <code>Foldable</code>. This should apply the <em>rest</em> of the alter function,
 with the <em>rest</em> of the <code>Foldable</code>, depending on the result of the
 lookup. </li></ul><p>This can be thought of as parallel to <code><a href="Trie.html#v:follow">follow</a></code>, where <code><a href="Trie.html#v:follow">follow</a></code> 
 follows a <code>Foldable</code>, and then deals with either the Foldable 
 being exhausted, or the next element not being found. <code><a href="Trie.html#v:alter">alter</a></code> 
 similarly follows a <code>Foldable</code> down a Trie, but it preserves the 
 rest of the Trie, and performs the required cleanup. (i.e, a 
 branch of a Trie with no <code>endHere</code>s set to <code>True</code> is not 
 preserved.)</p><p>Examples:</p><ul><li>Insert</li></ul><pre>insert = alter (. fromMaybe empty) (overEnd (const True))</pre><p>Here, the first argument to alter says that if the next element of 
 the <code>Foldable</code> can't be found, then just give an empty Trie in its 
 place. When the <code>Foldable</code> is exhausted, though, call 
 'overEnd (const True)' on the final Trie found. (
 'overEnd (const True)' sets the boolean end flag to True.)</p><ul><li>Delete</li></ul><pre>delete = alter (=&lt;&lt;) (overEnd (const False))</pre><p>Here, the first argument says that if the next element cannot be 
 found, pass the <code>Nothing</code> back up along the chain. Otherwise, 
 turns the end to <code>False</code>.</p></div></div><h1 id="g:5">Combine</h1><div class="top"><p class="src"><a name="v:difference" class="def">difference</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Returns a Trie of the members of the first Trie not existing in
 the second Trie.</p></div></div><div class="top"><p class="src"><a name="v:symmetricDifference" class="def">symmetricDifference</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Returns a Trie of the members that exist in eithe the first 
 Trie, or the second Trie, or both.</p></div></div><div class="top"><p class="src"><a name="v:union" class="def">union</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Returns a Trie of the members that exist in either Trie.</p></div></div><div class="top"><p class="src"><a name="v:unions" class="def">unions</a> :: (Ord a, Foldable f) =&gt; f (<a href="Trie.html#t:Trie">Trie</a> a) -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Union of a foldable of Tries.</p></div></div><div class="top"><p class="src"><a name="v:intersection" class="def">intersection</a> :: Ord a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Returns a Trie of the elements in both the first and second Trie</p></div></div><h1 id="g:6">Folds</h1><div class="top"><p class="src"><a name="v:foldrTrie" class="def">foldrTrie</a> :: ([a] -&gt; b -&gt; b) -&gt; b -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; b</p><div class="doc"><p>Folds over the members of a Trie, in list form.</p></div></div><h1 id="g:7">Lists</h1><div class="top"><p class="src"><a name="v:toList" class="def">toList</a> :: <a href="Trie.html#t:Trie">Trie</a> a -&gt; [[a]]</p><div class="doc"><p>Converts a Trie to a list of its members, in list form.</p></div></div><div class="top"><p class="src"><a name="v:fromList" class="def">fromList</a> :: (Ord a, Foldable f, Foldable g) =&gt; g (f a) -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Creates a Trie from a <code>Foldable</code> of <code>Foldable</code>s.</p></div></div><h1 id="g:8">Filters</h1><div class="top"><p class="src"><a name="v:begins" class="def">begins</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Returns a Trie of the members that begin with the given prefix.</p></div></div><div class="top"><p class="src"><a name="v:ends" class="def">ends</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; <a href="Trie.html#t:Trie">Trie</a> a</p><div class="doc"><p>Returns a Trie of the members that end with the given suffix.</p></div></div><h1 id="g:9">Debugging</h1><div class="top"><p class="src"><a name="v:showTrie" class="def">showTrie</a> :: Show a =&gt; <a href="Trie.html#t:Trie">Trie</a> a -&gt; String</p><div class="doc"><p>A textual representation of the Trie, suitable for debugging.</p><pre>let t = (fromList . words) &quot;house car roundabout round rounders\
                            carpet cat cap carpentry&quot;
putStrLn (showTrie t)

'c' 'a' 'p'|
        'r'|'p' 'e' 'n' 't' 'r' 'y'|
                    't'|
        't'|
'h' 'o' 'u' 's' 'e'|
'r' 'o' 'u' 'n' 'd'|'a' 'b' 'o' 'u' 't'|
                    'e' 'r' 's'|</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>